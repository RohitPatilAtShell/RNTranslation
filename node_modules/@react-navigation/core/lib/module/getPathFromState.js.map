{"version":3,"sources":["getPathFromState.tsx"],"names":["queryString","getPathFromState","state","options","path","current","index","route","routes","config","name","undefined","stringify","params","Object","entries","reduce","acc","key","value","String","pattern","split","map","p","replace","startsWith","encodeURIComponent","join"],"mappings":"iEAAA,MAAOA,CAAAA,WAAP,KAAwB,cAAxB,CAsCA,cAAe,SAASC,CAAAA,gBAAT,CACbC,KADa,CAGL,IADRC,CAAAA,OACQ,2DADW,EACX,CACR,GAAIC,CAAAA,IAAI,CAAG,GAAX,CAEA,GAAIC,CAAAA,OAA0B,CAAGH,KAAjC,CAHQ,2BAMN,GAAMI,CAAAA,KAAK,CAAG,MAAOD,CAAAA,OAAO,CAACC,KAAf,GAAyB,QAAzB,CAAoCD,OAAO,CAACC,KAA5C,CAAoD,CAAlE,CACA,GAAMC,CAAAA,KAAK,CAAGF,OAAO,CAACG,MAAR,CAAeF,KAAf,CAAd,CAIA,GAAMG,CAAAA,MAAM,CACVN,OAAO,CAACI,KAAK,CAACG,IAAP,CAAP,GAAwBC,SAAxB,CACKR,OAAO,CAACI,KAAK,CAACG,IAAP,CAAR,CAAyDE,SAD7D,CAEID,SAHN,CAKA,GAAME,CAAAA,MAAM,CAAGN,KAAK,CAACM,MAAN,CAEXC,MAAM,CAACC,OAAP,CAAeR,KAAK,CAACM,MAArB,EAA6BG,MAA7B,CAEG,SAACC,GAAD,MAAuB,kCAAhBC,GAAgB,UAAXC,KAAW,UACxBF,GAAG,CAACC,GAAD,CAAH,CAAWT,MAAM,EAAIA,MAAM,CAACS,GAAD,CAAhB,CAAwBT,MAAM,CAACS,GAAD,CAAN,CAAYC,KAAZ,CAAxB,CAA6CC,MAAM,CAACD,KAAD,CAA9D,CACA,MAAOF,CAAAA,GAAP,CACD,CALD,CAKG,EALH,CAFW,CAQXN,SARJ,CAUA,GAAIR,OAAO,CAACI,KAAK,CAACG,IAAP,CAAP,GAAwBC,SAA5B,CAAuC,CACrC,GAAMU,CAAAA,OAAO,CACX,MAAOlB,CAAAA,OAAO,CAACI,KAAK,CAACG,IAAP,CAAd,GAA+B,QAA/B,CACKP,OAAO,CAACI,KAAK,CAACG,IAAP,CADZ,CAEKP,OAAO,CAACI,KAAK,CAACG,IAAP,CAAR,CAA0CN,IAHhD,CAKAA,IAAI,EAAIiB,OAAO,CACZC,KADK,CACC,GADD,EAELC,GAFK,CAED,SAAAC,CAAC,CAAI,CACR,GAAMd,CAAAA,IAAI,CAAGc,CAAC,CAACC,OAAF,CAAU,IAAV,CAAgB,EAAhB,CAAb,CAGA,GAAIZ,MAAM,EAAIH,IAAI,GAAIG,CAAAA,MAAlB,EAA4BW,CAAC,CAACE,UAAF,CAAa,GAAb,CAAhC,CAAmD,CACjD,GAAMP,CAAAA,MAAK,CAAGN,MAAM,CAACH,IAAD,CAApB,CAEA,MAAOG,CAAAA,MAAM,CAACH,IAAD,CAAb,CACA,MAAOiB,CAAAA,kBAAkB,CAACR,MAAD,CAAzB,CACD,CAED,MAAOQ,CAAAA,kBAAkB,CAACH,CAAD,CAAzB,CACD,CAdK,EAeLI,IAfK,CAeA,GAfA,CAAR,CAgBD,CAtBD,IAsBO,CACLxB,IAAI,EAAIuB,kBAAkB,CAACpB,KAAK,CAACG,IAAP,CAA1B,CACD,CAED,GAAIH,KAAK,CAACL,KAAV,CAAiB,CACfE,IAAI,EAAI,GAAR,CACD,CAFD,IAEO,IAAIS,MAAJ,CAAY,CACjBT,IAAI,MAAQJ,WAAW,CAACY,SAAZ,CAAsBC,MAAtB,CAAZ,CACD,CAEDR,OAAO,CAAGE,KAAK,CAACL,KAAhB,CA1DM,EAKR,MAAOG,OAAP,CAAgB,SAsDf,CAED,MAAOD,CAAAA,IAAP,CACD","sourcesContent":["import queryString from 'query-string';\nimport { NavigationState, PartialState, Route } from './types';\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype Options = {\n  [routeName: string]: string | { path: string; stringify?: StringifyConfig };\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * Example:\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       stringify: { author: author => author.toLowerCase() }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState(\n  state: State,\n  options: Options = {}\n): string {\n  let path = '/';\n\n  let current: State | undefined = state;\n\n  while (current) {\n    const index = typeof current.index === 'number' ? current.index : 0;\n    const route = current.routes[index] as Route<string> & {\n      state?: State | undefined;\n    };\n\n    const config =\n      options[route.name] !== undefined\n        ? (options[route.name] as { stringify?: StringifyConfig }).stringify\n        : undefined;\n\n    const params = route.params\n      ? // Stringify all of the param values before we use them\n        Object.entries(route.params).reduce<{\n          [key: string]: string;\n        }>((acc, [key, value]) => {\n          acc[key] = config && config[key] ? config[key](value) : String(value);\n          return acc;\n        }, {})\n      : undefined;\n\n    if (options[route.name] !== undefined) {\n      const pattern =\n        typeof options[route.name] === 'string'\n          ? (options[route.name] as string)\n          : (options[route.name] as { path: string }).path;\n\n      path += pattern\n        .split('/')\n        .map(p => {\n          const name = p.replace(/^:/, '');\n\n          // If the path has a pattern for a param, put the param in the path\n          if (params && name in params && p.startsWith(':')) {\n            const value = params[name];\n            // Remove the used value from the params object since we'll use the rest for query string\n            delete params[name];\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (params) {\n      path += `?${queryString.stringify(params)}`;\n    }\n\n    current = route.state;\n  }\n\n  return path;\n}\n"]}