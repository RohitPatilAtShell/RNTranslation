{"version":3,"sources":["getStateFromPath.tsx"],"names":["getStateFromPath","path","options","routeConfig","Object","keys","map","key","pattern","match","RegExp","replace","routeName","parse","result","current","remaining","params","config","paramPatterns","split","filter","p","startsWith","length","reduce","acc","i","value","undefined","segments","decodeURIComponent","shift","join","state","routes","name","query","route","queryString","forEach"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport { NavigationState, PartialState } from './types';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]: string | { path: string; parse?: ParseConfig };\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): PartialState<NavigationState> | undefined {\n  // Create a normalized config array which will be easier to use\n  const routeConfig = Object.keys(options).map(key => {\n    const pattern =\n      typeof options[key] === 'string'\n        ? (options[key] as string)\n        : (options[key] as { path: string }).path;\n\n    // Create a regex from the provided path pattern\n    // With the pattern, we can match segements containing params and extract them\n    const match = new RegExp(\n      '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n    );\n\n    return {\n      match,\n      pattern,\n      routeName: key,\n      // @ts-ignore\n      parse: options[key].parse,\n    };\n  });\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeName;\n    let params;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of routeConfig) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeName = config.routeName;\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter(p => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeName === undefined) {\n      const segments = remaining.split('/');\n\n      routeName = decodeURIComponent(segments[0]);\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    const state = {\n      routes: [{ name: routeName, params }],\n    };\n\n    if (current) {\n      // The state should be nested inside the route we parsed before\n      current.routes[0].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    const route = current.routes[0];\n\n    const params = queryString.parse(query);\n    const config = options[route.name]\n      ? (options[route.name] as { parse?: ParseConfig }).parse\n      : undefined;\n\n    if (config) {\n      Object.keys(params).forEach(name => {\n        if (config[name] && typeof params[name] === 'string') {\n          params[name] = config[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n"]}