{"version":3,"sources":["useEventEmitter.tsx"],"names":["useEventEmitter","listeners","React","useRef","create","useCallback","target","removeListener","type","callback","callbacks","current","undefined","index","indexOf","splice","addListener","push","emit","data","items","slice","concat","Object","keys","map","t","defaultPrevented","event","preventDefault","forEach","cb","useMemo"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { EventEmitter, EventConsumer, EventArg } from './types';\n\nexport type NavigationEventEmitter = EventEmitter<Record<string, any>> & {\n  create: (target: string) => EventConsumer<Record<string, any>>;\n};\n\ntype Listeners = Array<(data: any) => void>;\n\n/**\n * Hook to manage the event system used by the navigator to notify screens of various events.\n */\nexport default function useEventEmitter(): NavigationEventEmitter {\n  const listeners = React.useRef<Record<string, Record<string, Listeners>>>({});\n\n  const create = React.useCallback((target: string) => {\n    const removeListener = (type: string, callback: (data: any) => void) => {\n      const callbacks = listeners.current[type]\n        ? listeners.current[type][target]\n        : undefined;\n\n      if (!callbacks) {\n        return;\n      }\n\n      const index = callbacks.indexOf(callback);\n\n      callbacks.splice(index, 1);\n    };\n\n    const addListener = (type: string, callback: (data: any) => void) => {\n      listeners.current[type] = listeners.current[type] || {};\n      listeners.current[type][target] = listeners.current[type][target] || [];\n      listeners.current[type][target].push(callback);\n\n      return () => removeListener(type, callback);\n    };\n\n    return {\n      addListener,\n      removeListener,\n    };\n  }, []);\n\n  const emit = React.useCallback(\n    ({ type, data, target }: { type: string; data?: any; target?: string }) => {\n      const items = listeners.current[type] || {};\n\n      // Copy the current list of callbacks in case they are mutated during execution\n      const callbacks =\n        target !== undefined\n          ? items[target] && items[target].slice()\n          : ([] as Listeners).concat(...Object.keys(items).map(t => items[t]));\n\n      let defaultPrevented = false;\n\n      const event: EventArg<any, any> = {\n        get type() {\n          return type;\n        },\n        get data() {\n          return data;\n        },\n        get defaultPrevented() {\n          return defaultPrevented;\n        },\n        preventDefault() {\n          defaultPrevented = true;\n        },\n      };\n\n      callbacks && callbacks.forEach(cb => cb(event));\n\n      return event;\n    },\n    []\n  );\n\n  return React.useMemo(() => ({ create, emit }), [create, emit]);\n}\n"]}